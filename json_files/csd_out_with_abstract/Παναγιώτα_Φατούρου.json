[{
    "name": "\u03a0\u03b1\u03bd\u03b1\u03b3\u03b9\u03ce\u03c4\u03b1 \u03a6\u03b1\u03c4\u03bf\u03cd\u03c1\u03bf\u03c5",
    "romanize name": "Panagiota Fatourou",
    "School-Department": "\u0395\u03c0\u03b9\u03c3\u03c4\u03ae\u03bc\u03b7\u03c2 \u03a5\u03c0\u03bf\u03bb\u03bf\u03b3\u03b9\u03c3\u03c4\u03ce\u03bd",
    "University": "uoc",
    "Rank": "\u039a\u03b1\u03b8\u03b7\u03b3\u03ae\u03c4\u03c1\u03b9\u03b1",
    "Apella_id": 9534,
    "Scholar name": "Panagiota Fatourou",
    "Scholar id": "ZgHRkcUAAAAJ",
    "Affiliation": "Professor, Department of Computer Science, University of Crete",
    "Citedby": 1069,
    "Interests": [
        "Parallel and Distributed Computing (emphasis in theory)"
    ],
    "Scholar url": "https://scholar.google.com/citations?user=ZgHRkcUAAAAJ&hl=en",
    "Publications": [
        {
            "Title": "The space complexity of unbounded timestamps",
            "Publication year": 2008,
            "Publication url": "https://link.springer.com/content/pdf/10.1007/s00446-008-0060-6.pdf",
            "Abstract": "The timestamp problem captures a fundamental aspect of asynchronous distributed computing. It allows processes to label events throughout the system with timestamps that provide information about the real-time ordering of those events. We consider the space complexity of wait-free implementations of timestamps from shared read-write registers in a system of n processes. We prove an  lower bound on the number of registers required. If the timestamps are elements of a nowhere dense set, for example the integers, we prove a stronger, and tight, lower bound of n. However, if timestamps are not from a nowhere dense set, this bound can be beaten: we give an implementation that uses n \u2212 1 (single-writer) registers. We also consider the special case of anonymous implementations, where processes are programmed identically and do not have unique identifiers. In contrast to the general case, we \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:ZeXyd9-uunAC",
            "Publisher": "Springer-Verlag"
        },
        {
            "Title": "Low-contention depth-first scheduling of parallel computations with write-once synchronization variables",
            "Publication year": 2001,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/378580.378639",
            "Abstract": "We present an efficient, randomized, online, scheduling algorithm for a large class of programs with write-once synchronization variables. The algorithm combines the work-stealing paradigm with the depth-first scheduling technique, resulting in high space efficiency and good time complexity. By automatically increasing the granularity of the work scheduled on each processor, our algorithm achieves good locality, low contention and low scheduling overhead, improving upon a previous depth-first scheduling algorithm [6] published in SPAA'97. Moreover, it is probably efficient for the general class of multithreaded computations with write-once synchronization variables (as studied in [6]), improving upon algorithm DFDeques (published in SPAA'99 [24]), which is only for the more restricted class of nested parallel computations.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:0EnyYjriUFMC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Blocking Universal Constructions",
            "Publication year": 2011,
            "Publication url": "https://www.researchgate.net/profile/Nikolaos-Kallimanis/publication/228973719_Blocking_Universal_Constructions/links/5469f82e0cf2f5eb18076fc9/Blocking-Universal-Constructions.pdf",
            "Abstract": "In this paper, we present two new blocking universal constructions. The first one, called CC-BSim, is very efficient in systems that support coherent caches (CC), while the second one, called DSM-BSim, is more efficient in cache-less NUMA machines (where processors do not have caches). CC-BSim performs at most O (h+ t) remote memory references (RMR), where h is an upper bound on the number of operations that a process may help, and t is the size of the part of the object\u2019s state that it should be accessed in order to execute these h operations. DSM-BSim performs at most O (hw) RMR, where w is the number of memory words accessed by the sequential version of an operation applied on a sequential data structure. DSM-BSim is better suited in a distributed shared memory (DSM) model. Algorithm CC-BSim uses just one Swap object in addition to read-write registers, thus exhibiting a performance advantage in machines that support Swap objects. On the other hand, DSM-BSim uses CAS, Swap, and read-write registers.Our experiments show that CC-BSim and DSM-BSim outperform state-of-the-art synchronization techniques, like Sim (SPAA 2001), flat-combining (SPAA 2010), and others. We also present and experimentally analyze common shared data structures (like shared stacks and queues) based on CC-BSim and DSM-BSim. Our experiments show that these implementations have very good performance in practice.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:_kc_bZDykSQC",
            "Publisher": "Technical report, University of Ioannina, 2011. TR-2011-05"
        },
        {
            "Title": "Research Directions in Distributed Computing",
            "Publication year": 2013,
            "Publication url": "Unknown",
            "Abstract": "Unknown",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:hFOr9nPyWt4C",
            "Publisher": "Unknown"
        },
        {
            "Title": "Efficiency of oblivious versus nonoblivious schedulers for optimistic, rate-based flow control",
            "Publication year": 2005,
            "Publication url": "https://epubs.siam.org/doi/abs/10.1137/S009753970343275X",
            "Abstract": "Two important performance parameters of distributed, rate-based flow control algorithms are their locality and  convergence complexity. The former is characterized by the amount of global knowledge that is available to their scheduling mechanisms, while the latter is defined as the number of update operations performed on rates of individual sessions until max-min fairness is reached. Optimistic algorithms allow any session to intermediately receive a rate larger than its max-min fair rate; bottleneck algorithms finalize the rate of a session only if it is restricted by a certain, highly congested link of the network. In this work, we present a comprehensive collection of lower and upper bounds on convergence complexity, under varying degrees of locality, for optimistic, bottleneck, rate-based flow control algorithms.Say that an algorithm is oblivious if its scheduling mechanism uses no information of either the session rates or the network \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:dhFuZR0502QC",
            "Publisher": "Society for Industrial and Applied Mathematics"
        },
        {
            "Title": "VAT: Asymptotic Cost Analysis for Multi-Level Key-Value Stores",
            "Publication year": 2020,
            "Publication url": "https://arxiv.org/abs/2003.00103",
            "Abstract": "Over the past years, there has been an increasing number of key-value (KV) store designs, each optimizing for a different set of requirements. Furthermore, with the advancements of storage technology the design space of KV stores has become even more complex. More recent KV-store designs target fast storage devices, such as SSDs and NVM. Most of these designs aim to reduce amplification during data reorganization by taking advantage of device characteristics. However, until today most analysis of KV-store designs is experimental and limited to specific design points. This makes it difficult to compare tradeoffs across different designs, find optimal configurations and guide future KV-store design. In this paper, we introduce the Variable Amplification- Throughput analysis (VAT) to calculate insert-path amplification and its impact on multi-level KV-store performance.We use VAT to express the behavior of several existing design points and to explore tradeoffs that are not possible or easy to measure experimentally. VAT indicates that by inserting randomness in the insert-path, KV stores can reduce amplification by more than 10x for fast storage devices. Techniques, such as key-value separation and tiering compaction, reduce amplification by 10x and 5x, respectively. Additionally, VAT predicts that the advancements in device technology towards NVM, reduces the benefits from both using key-value separation and tiering.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:zA6iFVUQeVQC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Space-optimal multi-writer snapshot objects are slow",
            "Publication year": 2002,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/571825.571828",
            "Abstract": "We consider the problem of wait-free implementation of a multi-writer snapshot object with m\u2265 2 components shared by n> m processes. It is known that this can be done using m multi-writer registers. We give a matching lower bound, slightly improving the previous space lower bound. The main focus of the paper, however, is on time complexity. The best known upper bound on the number of steps a process has to take to perform one operation of the snapshot is O (n). When m is much smaller than n, an implementation whose time complexity is a function of m rather than n would be better. We show that this cannot be achieved for any space-optimal implementation: We prove that \u03a9 (n) steps are required to perform a SCAN operation in the worst case, even if m= 2. This significantly improves previous \u03a9 (min (m, n)) lower bounds. Our proof also yields insight into the structure of any space-optimal implementation \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:qjMakFHDy7sC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Tracking in order to recover: Recoverable lock-free data structures",
            "Publication year": 2019,
            "Publication url": "https://arxiv.org/abs/1905.13600",
            "Abstract": "We present the \\emph{tracking approach} for deriving \\emph{recoverable} implementations of several widely-used concurrent data structures. Recoverability is appealing for emerging systems featuring byte-addressable \\emph{non-volatile main memory} (\\emph{NVRAM}), whose durability allows to efficiently resurrect a failed process after it crashes. The tracking approach ensures that after a crash occurs, every executed operation is able to recover and return a correct response, in addition to guaranteeing that the state of the data structure is not corrupted. The approach is applicable to lock-free concurrent data structures that use helping and rely on information structures to track the progress of operations. Such a tracking mechanism is already present in a wide range of well-known concurrent data structures, in particular, linked lists, trees and elimination stacks, making it relatively easy to derive their recoverable versions using the tracking approach. The tracking approach illustrates that full-fledged logging is not needed and ensures that the progress of concurrent operations is tracked in a \\emph{per-process} manner, thus reducing the cost of ensuring recoverability.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:vV6vV6tmYwMC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Introduction to Sockets Programming in C using TCP/IP",
            "Publication year": 2012,
            "Publication url": "http://www.csd.uoc.gr/~hy556/material/tutorials/cs556-3rd-tutorial.pdf",
            "Abstract": "Introduction to Sockets Programming in C using TCP/IP Page 1 Introduction to Sockets \nProgramming in C using TCP/IP Professor: Panagiota Fatourou TA: Eleftherios Kosmas \nCSD - May 2012 Page 2 Introduction CS556 - Distributed Systems Tutorial by Eleftherios \nKosmas 2 \u220e Computer Network \u2751 hosts, routers, communication channels \u220e Hosts run \napplications \u220e Routers forward information \u220e Packets: sequence of bytes \u2751 contain control \ninformation \u2751 eg destination host \u220e Protocol is an agreement \u2751 meaning of packets \u2751 \nstructure and size of packets eg Hypertext Transfer Protocol (HTTP) Host Router \nCommunication channel Page 3 Protocol Families - TCP/IP CS556 - Distributed Systems \nTutorial by Eleftherios Kosmas 3 \u220e Several protocols for different problems \u261eProtocol \nSuites or Protocol Families: TCP/IP \u220e TCP/IP provides end-to-end connectivity specifying \nhow data should be \u2751 formatted, \u2751 addressed, \u2751 , -\u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:M05iB0D1s5AC",
            "Publisher": "Unknown"
        },
        {
            "Title": "The Distributed Computing Column.",
            "Publication year": 2010,
            "Publication url": "https://www.gsd.inesc-id.pt/~romanop/files/papers/wttm14.pdf",
            "Abstract": "This year, the 6th edition of the Workshop on Theory of Transactional Memory (WTTM) was collocated with PODC 2014 in Paris, and took place on July 14. The objective of WTTM was to discuss new theoretical challenges and recent achievements in the area of transactional computing. Among the various recent developments in the area of Transactional Memory (TM), one of the most relevant was the support for Hardware TM (HTM), which was introduced in various commercial processors. Unsurprisingly, the recent advent of HTM in commercial CPUs has had a major impact also in the program of this edition of WTTM, which has gathered several works addressing issues related to the programmability, efficiency, and correctness of HTM-based systems, as well as hybrid solutions combining software and hardware TM implementations (HyTM). As in its previous editions, WTTM could count on the generous support of the EuroTM COST Action (IC1001), and on a set of outstanding keynote talks which were delivered by some of the leading researchers in the area, namely Idit Keidar, Shlomi Dolev, Maged Michael and Michael Scott, who were invited to present their latest achievements. This edition was dedicated to the 60th birthday of Maurice Herlihy and to his foundational work on Transactional Memory, which was commemorated by Michael Scott in the concluding talk of the event. This report is intended to give the highlights of the problems discussed during the workshop.Transactional Memory (TM) is a concurrency control mechanism for synchronizing concurrent accesses to shared memory by different threads. It has been proposed as an \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:7PzlFSSx8tAC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Towards the Synthesis of Coherence/Replication Protocols from Consistency Models via Real-Time Orderings",
            "Publication year": 2021,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3447865.3457964",
            "Abstract": "This work focuses on shared memory systems with a read-write interface (eg, distributed datastores or multiprocessors). At the heart of such systems resides a protocol responsible for enforcing their consistency guarantees. Designing a protocol that correctly and efficiently enforces consistency is a very challenging task. Our overarching vision is to automate this task. In this work we take a step towards this vision by establishing the theoretical foundation necessary to automatically infer a protocol from a consistency specification. Specifically, we propose a set of mathematical abstractions, called real-time orderings (rt-orderings), that model the protocol. We then create a mapping from consistency guarantees to the minimal rt-orderings that enforce the guarantees. Finally, we informally relate the rt-orderings to protocol implementation techniques. Consequently, rt-orderings serve as an intermediate abstraction \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:pyW8ca7W8N0C",
            "Publisher": "Unknown"
        },
        {
            "Title": "SING: Sequence Indexing Using GPUs",
            "Publication year": 2021,
            "Publication url": "https://ieeexplore.ieee.org/abstract/document/9458657/",
            "Abstract": "Data series similarity search is a core operation for several data series analysis applications across many domains. This has attracted lots of interest that led to the development of several indexing techniques. Nevertheless, these techniques fail to deliver the similarity search time performance that is needed for interactive exploration, or analysis of large data series collections. We propose SING, the first data series index designed to take advantage of Graphics Processing Units (GPUs). SING is an in-memory index that uses CPU+GPU co-processing (as well as SIMD, multi-core and multi-socket architectures), in order to accelerate similarity search. Our experimental evaluation with synthetic and real datasets shows that SING is up to 5.1x faster than the state-of-the-art parallel in-memory approach, and up to 62x faster than the state-of-the-art parallel serial scan algorithm. SING achieves exact similarity search query \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:a0OBvERweLwC",
            "Publisher": "IEEE"
        },
        {
            "Title": "Maurice Herlihy\u2019s 60th Birthday Celebration",
            "Publication year": 2015,
            "Publication url": "http://bulletin.eatcs.org/index.php/beatcs/article/download/344/326",
            "Abstract": "Maurice Herlihy is one of the most renowned members of the Distributed Computing community. He is currently a professor in the Computer Science Department at Brown University. He has an AB in Mathematics from Harvard University, and a Ph. D. in Computer Science from MIT He has served on the faculty of Carnegie Mellon University and on the staff of DEC Cambridge Research Lab. He is the recipient of the 2003 Dijkstra Prize in Distributed Computing, the 2004 G\u00f6del Prize in theoretical computer science, the 2008 ISCA influential paper award, the 2012 Edsger W. Dijkstra Prize, and the 2013 Wallace McDowell award. He received a 2012 Fullbright Distinguished Chair in the Natural Sciences and Engineering Lecturing Fellowship, and he is a fellow of the ACM, a fellow of the National Academy of Inventors, and a member of the National Academy of Engineering and the American Academy of Arts and Sciences. On the occasion of his 60th birthday, the SIGACT-SIGOPS Symposium on Principles of Distributed Computing (PODC), which was held in Paris, France in July 2014, hosted a celebration which included several technical presentations about Maurice\u2019s work by colleagues and friends. This column includes a summary of some of these presentations, written by the speakers themselves. In the first article, Vassos Hadzilacos overviews and highlights the impact of Maurice\u2019s seminal paper on wait-free synchronization. Then, Tim Harris provides a perspective on hardware trends and their impact on distributed computing, mentioning several interesting open problems and making connections to Maurice\u2019s work. Finally, Michael Scott gives \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:M3NEmzRMIkIC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Highly-efficient wait-free synchronization",
            "Publication year": 2014,
            "Publication url": "https://link.springer.com/article/10.1007/s00224-013-9491-y",
            "Abstract": "We study a simple technique, originally presented by Herlihy (ACM Trans. Program. Lang. Syst. 15(5):745\u2013770, 1993), for executing concurrently, in a wait-free manner, blocks of code that have been programmed for sequential execution and require significant synchronization in order to be performed in parallel. We first present an implementation of this technique, called Sim, which employs a collect object. We describe a simple implementation of a collect object from a single shared object that supports atomic Add (or XOR) in addition to read; this implementation has step complexity O(1). By plugging in to Sim this implementation, Sim exhibits constant step complexity as well. This allows us to derive lower bounds on the step complexity of implementations of several shared objects, like Add, XOR, collect, and snapshot objects, from LL/SC objects.We then present a practical version of Sim, called \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:qUcmZB5y_30C",
            "Publisher": "Springer US"
        },
        {
            "Title": "LIPIcs, Volume 70, OPODIS'16, Complete Volume",
            "Publication year": 2017,
            "Publication url": "https://drops.dagstuhl.de/opus/volltexte/2017/7111/pdf/lipics-vol70-opodis2016-complete.pdf",
            "Abstract": "OPODIS is an open forum for the exchange of state-of-the-art knowledge on distributed computing. With strong roots in the theory of distributed systems, OPODIS has expanded its scope to cover the whole range between the theoretical aspects and practical implementations of distributed systems, as well as experimentation and quantitative assessments. All aspects of distributed systems are within the scope of OPODIS: theory, specification, design, performance, and system building. Specifically, this year the topics of interest of OPODIS included:Design and analysis of distributed algorithms Synchronization, concurrent algorithms, shared and transactional memory Design and analysis of concurrent and distributed data structures Communication networks (protocols, architectures, services, applications) High-performance, cluster, cloud and grid computing Mesh and ad-hoc networks (wireless, mobile, sensor), location and context-aware systems Mobile agents, robots, and rendezvous",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:TQgYirikUcIC",
            "Publisher": "Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik"
        },
        {
            "Title": "Linearizable wait-free iteration operations in shared double-ended queues",
            "Publication year": 2017,
            "Publication url": "https://www.worldscientific.com/doi/abs/10.1142/S0129626417500013",
            "Abstract": "Shared data object implementations that allow non-blocking concurrent operations are useful for in-memory data-processing, especially when they support consistent bulk operations like iterations. We propose an algorithmic implementation for concurrent iterators on shared double-ended queues (deques), building on and complementing a known lock-free deque implementation by M. Michael. The proposed construction is linearizable and wait-free. Moreover, it is read-only, so it does not execute expensive synchronization primitives and it does not interfere with update operations.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:GnPB-g6toBAC",
            "Publisher": "World Scientific Publishing Company"
        },
        {
            "Title": "WFR-TM: wait-free readers without sacrificing speculation of writers",
            "Publication year": 2016,
            "Publication url": "https://www.sciencedirect.com/science/article/pii/S0743731516300326",
            "Abstract": "Transactional Memory (TM) is a promising concurrent programming paradigm which employs transactions to achieve synchronization in accessing common data known as transactional variables. A transaction may either commit, making its updates to transactional variables visible, or abort, discarding its updates.We introduce WFR-TM, a TM  algorithm which attempts to combine the advantages of pessimistic and optimisticTM. In a pessimistic TM, no transaction ever aborts; however, current pessimistic TM  implementations, execute update transactions sequentially, decreasing the degree of achieved parallelism. In optimistic TM, transactions are executed concurrently and they commit if they have encountered no conflict during their execution.In WFR-TM, read-only transactions not only are wait-free, but also they never execute expensive synchronization operations (like CAS, LL/SC, etc.). This is achieved without \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:blknAaTinKkC",
            "Publisher": "Academic Press"
        },
        {
            "Title": "Algorithmic techniques in stm design",
            "Publication year": 2015,
            "Publication url": "https://link.springer.com/chapter/10.1007/978-3-319-14720-8_5",
            "Abstract": "The Transactional Memory paradigm has gained a lot of momentum in recent years. This is evidenced by the plethora of software transactional memory (STM) algorithms that can be found in the literature. Although their goal is common - to offer the transaction abstraction to the programmer - the implementations that they provide for this abstraction show a great variation among them. This variation appears as different algorithms aim at exhibiting different additional properties, such as offering specific liveness guarantees or good performance or both. In this chapter, we identify the basic characteristics of STM algorithms and the mechanisms that they are made up from. In conjunction with the design decisions, and in order to outline how they are used, we present in detail some representative STM algorithms. We also briefly discuss a lot of other STM algorithms found in the literature.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:JV2RwH3_ST0C",
            "Publisher": "Springer, Cham"
        },
        {
            "Title": "An Efficient Wait-free Resizable Hash Table",
            "Publication year": 2018,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3210377.3210408",
            "Abstract": "This paper presents an efficient wait-free resizable hash table. To achieve high throughput at large core counts, our algorithm is specifically designed to retain the natural parallelism of concurrent hashing, while providing wait-free resizing. An extensive evaluation of our hash table shows that in the common case where resizing actions are rare, our implementation outperforms all existing lock-free hash table implementations while providing a stronger progress guarantee.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:70eg2SAEIzsC",
            "Publisher": "Unknown"
        },
        {
            "Title": "An Efficient Universal Construction for Large Objects",
            "Publication year": 2020,
            "Publication url": "https://arxiv.org/abs/2001.03457",
            "Abstract": "This paper presents L-UC, a universal construction that efficiently implements dynamic objects of large state in a wait-free manner. The step complexity of L-UC is O(n+kw), where n is the number of processes, k is the interval contention (i.e., the maximum number of active processes during the execution interval of an operation), and w is the worst-case time complexity to perform an operation on the sequential implementation of the simulated object. L-UC efficiently implements objects whose size can change dynamically. It improves upon previous universal constructions either by efficiently handling objects whose state is large and can change dynamically, or by achieving better step complexity.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:pqnbT2bcN3wC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Time Optimal, Space-efficient Single-Scanner Snapshots & Efficient Multi-Scanner Snapshots using CAS",
            "Publication year": 2007,
            "Publication url": "https://www.csd.uoc.gr/~hy586/old_websites/2009_2010/material/exercises/podc2007.pdf",
            "Abstract": "Snapshots are fundamental shared objects which provide consistent views of blocks of shared memory. A snapshot object consists of an array of m memory cells and allows processes to execute UPDATES to write new values in any of the snapshot cells, and SCANS to return consistent views of all m cells. An interesting (weaker) form of snapshot with several applications is a singlescanner snapshot which allows to only one process, called scanner, to execute SCANS (UPDATES can still be executed concurrently).We present the first time-optimal, linearizable, wait-free, single-scanner snapshot implementations from read-write registers for an asynchronous system of n processes. Our first algorithm is very simple and has time complexity O (1) for UPDATE and O (m) for SCAN (which is optimal). However, in systems with no garbage collector, the number of registers it uses is proportional to the number of executed SCANS. Our second implementation employs an interesting recycling tecnique to reduce the space complexity to O (mn) bounded-size registers still achieving optimal time complexities for both operations. For systems that provide stronger primitives, like Compare-And-Swap (CAS), we provide a multi-scanner snapshot implementation that uses m CAS registers and m read-write registers, and achieves time complexity O (1) for UPDATE and O (m) for SCAN. The presented algorithms are simple and practical, and improve upon all previously presented algorithms in terms of time and/or space complexity.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:ULOm3_A8WrAC",
            "Publisher": "DCS"
        },
        {
            "Title": "Single-scanner multi-writer snapshot implementations are fast!",
            "Publication year": 2006,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/1146381.1146416",
            "Abstract": "Snapshot objects allow processes to obtain consistent global views of shared memory. A snapshot object consists of m components each capable of storing a value. The processes execute UPDATE operations to write new values in any of the components and SCANS to obtain consistent views of the snapshot contents. A single-scanner snapshot object supports only one active SCAN at any point in time (although UPDATES can still be executed concurrently). This paper studies wait-free, linearizable, single-scanner, multi-writer snapshot implementations from registers in an asynchronous shared-memory system, and presents a collection of upper and lower bounds on their complexity. We provide the first such implementations with time complexities that are (linear or quadratic) functions only of the number of snapshot components and not of the number of processes. Moreover, we argue that single-scanner \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:LkGwnXOMwfcC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Brief Announcement: Persistent Software Combining",
            "Publication year": 2021,
            "Publication url": "https://drops.dagstuhl.de/opus/volltexte/2021/14858/",
            "Abstract": "We study the performance power of software combining in designing recoverable algorithms and data structures. We present two recoverable synchronization protocols, one blocking and another wait-free, which illustrate how to use software combining to achieve both low persistence and synchronization cost. Our experiments show that these protocols outperform by far state-of-the-art recoverable universal constructions and transactional memory systems. We built recoverable queues and stacks, based on these protocols, that exhibit much better performance than previous such implementations.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:abG-DnoFyZgC",
            "Publisher": "Schloss Dagstuhl-Leibniz-Zentrum f\u00fcr Informatik"
        },
        {
            "Title": "Survey on consistency conditions",
            "Publication year": 2013,
            "Publication url": "https://ics.forth.gr/tech-reports/2013/2013.TR439_Survey_on_Consistency_Conditions.pdf",
            "Abstract": "This survey provides formal definitions of consistency conditions for Transactional Memory. For reasons of completeness, a big collection of consistency conditions from other relevant fields, such as shared-memory consistency and consistency for database systems, are also studied.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:hC7cP41nSMkC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Time-optimal, space-efficient single-scanner snapshots & multi-scanner snapshots using CAS",
            "Publication year": 2007,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/1281100.1281108",
            "Abstract": "Snapshots are fundamental shared objects which provide consistent views of blocks of shared memory. A snapshot object consists of an array of m memory cells and allows processes to execute UPDATES to write new values in any of the snapshot cells, and SCANS to return consistent views of all m cells. An interesting (weaker) form of snapshot with several applications is a single-scanner snapshot which allows to only one process, called scanner, to execute SCANS (UPDATES can still be executed concurrently).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:W7OEmFMy1HYC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Women are needed in STEM: European policies and incentives",
            "Publication year": 2019,
            "Publication url": "https://dl.acm.org/doi/pdf/10.1145/3312565",
            "Abstract": "Achieving GE will significantly advance the STEM labor force, research and innovation, enhance the economy, and reduce the risk of women\u2019s social exclusion to the benefit of society. This article considers the main issues regarding GE in STEM in Europe including an analysis of the reasons for its necessity; a description of the European Union\u2019s strategy, measures, initiatives, and activities toward achieving GE; and, finally, their anticipated impact.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:_Qo2XoVZTnwC",
            "Publisher": "ACM"
        },
        {
            "Title": "Brief Announcement: Adding Networks",
            "Publication year": 2001,
            "Publication url": "https://tildeweb.au.dk/~au121/alcom-ft/TR/ALCOMFT-TR-01-76.ps.gz",
            "Abstract": "An adding network is a distributed data structure that supports a concurrent, lock-free, low-contention implementation of a fetch&add counter. We give a lower bound showing that adding networks have inherently high latency. We prove that our lower bound is tight.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:k_IJM867U9cC",
            "Publisher": "Association for Computing Machinery"
        },
        {
            "Title": "Non-blocking binary search trees",
            "Publication year": 2010,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/1835698.1835736",
            "Abstract": "This paper describes the first complete implementation of a non-blocking binary search tree in an asynchronous shared-memory system using single-word compare-and-swap operations. The implementation is linearizable and tolerates any number of crash failures. Insert and Delete operations that modify different parts of the tree do not interfere with one another, so they can run completely concurrently. Find operations only perform reads of shared memory.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:u5HHmVD_uO8C",
            "Publisher": "Unknown"
        },
        {
            "Title": "The pcl theorem: Transactions cannot be parallel, consistent and live",
            "Publication year": 2014,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/2612669.2612690",
            "Abstract": "We show that it is impossible to design a transactional memory system which ensures parallelism, ie transactions do not need to synchronize unless they access the same application objects, while ensuring very little consistency, ie a consistency condition, called weak adaptive consistency, introduced here and which is weaker than snapshot isolation, processor consistency, and any other consistency condition stronger than them (such as opacity, serializability, causal serializability, etc.), and very little liveness, ie that transactions eventually commit if they run solo.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:hMod-77fHWUC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Fast data series indexing for in-memory data",
            "Publication year": 2021,
            "Publication url": "https://link.springer.com/article/10.1007/s00778-021-00677-2",
            "Abstract": "Data series similarity search is a core operation for several data series analysis applications across many different domains. However, the state-of-the-art techniques fail to deliver the time performance required for interactive exploration, or analysis of large data series collections. In this work, we propose MESSI, the first data series index designed for in-memory operation on modern hardware. Our index takes advantage of the modern hardware parallelization opportunities (ie, SIMD instructions, multi-socket and multi-core architectures), in order to accelerate both index construction and similarity search processing times. Moreover, it benefits from a careful design in the setup and coordination of the parallel workers and data structures, so that it maximizes its performance for in-memory operations. MESSI supports similarity search using both the Euclidean and dynamic time warping (DTW) distances. Our experiments \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:f2IySw72cVMC",
            "Publisher": "Springer Berlin Heidelberg"
        },
        {
            "Title": "Read-modify-write networks",
            "Publication year": 2004,
            "Publication url": "https://link.springer.com/content/pdf/10.1007/s00446-003-0097-5.pdf",
            "Abstract": "A read-modify-write register for a set of functions F provides an operation that atomically (1) returns the variable\u2019s current value v, and (2) replaces that value with f(v), where f is a function in F.A read-modify-write network is a distributed data structure that implements a concurrent, lock-free, low-contention read-modify-write register. For example, counting networks ([3]) are a family of read-modify-write networks that support atomic increments and decrements.We consider the problem of constructing read-modify-write networks for particular sets of functions. Of particular interest are the read-modify-write networks fetch&add, which add to the value an arbitrary number, and fetch&mul, which multiply the value by an arbitrary number.We identify a simple algebraic property of the function set F that requires any distributed read-modify-write implementation for F to have high latency. Any \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:WF5omc3nYNoC",
            "Publisher": "Springer-Verlag"
        },
        {
            "Title": "DISTRIBUTED COMPUTING COLUMN Maurice Herlihy's 60th Birthday Celebration",
            "Publication year": 2015,
            "Publication url": "https://scholar.google.com/scholar?cluster=11930573098156820355&hl=en&oi=scholarr",
            "Abstract": "Unknown",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:BqipwSGYUEgC",
            "Publisher": "EUROPEAN ASSOC THEORETICAL COMPUTER SCIENCE"
        },
        {
            "Title": "The RedBlue family of universal constructions.",
            "Publication year": 2020,
            "Publication url": "http://search.ebscohost.com/login.aspx?direct=true&profile=ehost&scope=site&authtype=crawler&jrnl=01782770&AN=146603799&h=3ZAO8Mq%2FtZogpDohr%2BOFOxI%2FwidgInHLwDqO7KvAqVIP0MBOUCSL4U%2BjgSjmAOXTwEknJpOuKX8OsW1M4SKUOA%3D%3D&crl=c",
            "Abstract": "A universal construction is a general mechanism for obtaining a concurrent implementation of any shared object from its sequential implementation. We present the family of RedBlue universal constructions which produce adaptive, linearizable, wait-free, concurrent implementations of shared objects. The proposed universal constructions improve upon previous universal constructions in terms of their step and/or space complexity. The first of these universal constructions, which serves as the keystone for the design of the other RedBlue algorithms, produces concurrent implementations with better step complexity than those produced by all previously presented universal constructions but it uses large LL/SC registers. The second universal construction significantly reduces the size of the required registers, whereas the last two are appropriate for the purpose of simulating large objects.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:ZHo1McVdvXMC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Disjoint-access parallelism in software transactional memory",
            "Publication year": 2015,
            "Publication url": "https://link.springer.com/chapter/10.1007/978-3-319-14720-8_4",
            "Abstract": "Disjoint-access parallelism captures the requirement that unrelated transactions progress independently, without interference, even if they occur at the same time. That is, an implementation should not cause two transactions, which are unrelated at the high-level, i.e. they access disjoint sets of data items, to simultaneously access the same low-level shared memory locations. This chapter will formalize this notion and will discuss if and when STM can achieve disjoint-access parallelism, by presenting impossibility results and discussing some of the disjoint-access parallel STM implementations. For example, no dynamic STM can be disjoint-access parallel, if it ensures wait-freedom for read-only transactions and a weak liveness property, known as minimal progress, for update transactions. In fact, even if transactions are static, STM implementations cannot be disjoint-access parallel, when read-only \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:maZDTaKrznsC",
            "Publisher": "Springer, Cham"
        },
        {
            "Title": "Snapshot isolation does not scale either",
            "Publication year": 2013,
            "Publication url": "https://ics.forth.gr/tech-reports/2013/2013.TR437_Snapshot_Isolation_Does_Not_Scale_Either.pdf",
            "Abstract": "Transactional memory (TM)[20, 25, 33] allows concurrent processes to execute operations on data items within atomic blocks of instructions, called transactions. The paradigm is appealing for its simplicity but implementing it efficiently is challenging. Ideally the TM system should not introduce any contention between transactions beyond that inherently due to the actual code of the transactions. In other words, if two transactions access disjoint sets of data items, then none of these transactions should delay the other one, ie, these transactions should not contend on any base object. This requirement has been called strict disjoint-access-parallelism. Base objects are low-level objects, which provide atomic primitives like read/write, load linked/store conditional, compare-and-swap, used to implement the TM system. Two transactions contend on some base object if both access that object during their executions and one of them performs a non-trivial operation on that object, ie an operation which updates its state.Disjoint-access-parallelism is met in the literature [2, 8, 15, 19, 26, 30] in many flavors (see the discussion in related work). Stronger versions of it, like strict disjoint-access-parallelism, result in more parallelism (and promote scalability) and therefore they are highly desirable when designing TM implementations: strict disjoint-access-parallelism is indeed ensured by blocking TM algorithms like TL [13]. Nevertheless, a transaction that locks a data item and gets paged out might block all other transactions for a long amount of time. One might require a liveness property that prevents such blocking. It was shown however in [18] that a TM cannot \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:IWHjjKOFINEC",
            "Publisher": "Technical Report TR-437, Foundation of Research and Technology\u2013Hellas (FORTH)"
        },
        {
            "Title": "Messi: In-memory data series indexing",
            "Publication year": 2020,
            "Publication url": "https://ieeexplore.ieee.org/abstract/document/9101877/",
            "Abstract": "Data series similarity search is a core operation for several data series analysis applications across many different domains. However, the state-of-the-art techniques fail to deliver the time performance required for interactive exploration, or analysis of large data series collections. In this work, we propose MESSI, the first data series index designed for in-memory operation on modern hardware. Our index takes advantage of the modern hardware parallelization opportunities (i.e., SIMD instructions, multi-core and multi-socket architectures), in order to accelerate both index construction and similarity search processing times. Moreover, it benefits from a careful design in the setup and coordination of the parallel workers and data structures, so that it maximizes its performance for in-memory operations. Our experiments with synthetic and real datasets demonstrate that overall MESSI is up to 4\u00d7 faster at index \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:g5m5HwL7SMYC",
            "Publisher": "IEEE"
        },
        {
            "Title": "Revisiting the combining synchronization technique",
            "Publication year": 2012,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/2145816.2145849",
            "Abstract": "Fine-grain thread synchronization has been proved, in several cases, to be outperformed by efficient implementations of the combining technique where a single thread, called the combiner, holding a coarse-grain lock, serves, in addition to its own synchronization request, active requests announced by other threads while they are waiting by performing some form of spinning. Efficient implementations of this technique significantly reduce the cost of synchronization, so in many cases they exhibit much better performance than the most efficient finely synchronized algorithms.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:9yKSN-GCB0IC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Schedulers for Optimistic Rate Based Flow Control.",
            "Publication year": 2016,
            "Publication url": "https://davidbader.net/publication/2016-bade/2016-bade.pdf",
            "Abstract": "We have a two-sided market, one side is a set U of men, the other side is a set V of women. The first part of the input also contains the mutually acceptable man-woman pairs E. This makes up a bipartite graph GU [V, E). The second part of the input contains the preference lists of each person, that is a weak order (may contain ties) on his/her acceptable pairs.A matching is a set of mutually disjoint acceptable man-woman pairs. Given a matching M, a man m and a woman w form a blocking pair, if they are an acceptable pair but are not partners in M, and they both prefer each other to their partner, or have no partner in M. That is either w is unmatched in M or w prefers m to her M-partner, and either m is unmatched in M or m",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:mVmsd5A6BfQC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Simple and efficient replication in chord",
            "Publication year": 2006,
            "Publication url": "https://www.actapress.com/PDFViewer.aspx?paperId=28793",
            "Abstract": "SIMPLE AND EFFICIENT REPLICATION IN CHORD Maria Christodoulidou and Panagiota \nFatourou Computer Science Department, University of Ioannina PO Box 1186, 45110 Ioannina \nGreece {mchristo, faturu}@cs.uoi.gr ABSTRACT In this paper we propose a simple replication \nalgorithm for Chord [SML+01]. The algorithm does not require extra space for the placement or \nthe management of the replicas which are well-distributed to the nodes of the system. Replica \nholders can be easily calculated so nodes can choose the closest one to route their requests. \nWe provide experimental results to show that replicated Chord has better performance not \nonly from a non- replicated Chord system but also from a replicated version of Chord based \non the use of multiple hash functions. KEY WORDS structured peer-to-peer systems, Chord, \nreplication 1. INTRODUCTION Peer-to-peer (P2P) overlay networks are distributed , , . . \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:kNdYIx-mwKoC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Lower and upper bounds for single-scanner snapshot implementations",
            "Publication year": 2017,
            "Publication url": "https://link.springer.com/article/10.1007/s00446-016-0286-7",
            "Abstract": "We present a collection of upper and lower bounds on the complexity of asynchronous, wait-free, linearizable, single-scanner snapshot implementations from read\u2013write registers. We argue that at least m registers are needed to implement a single-scanner snapshot with m components and we prove that, in space-optimal implementations, SCANS execute  steps. We present an algorithm that runs in  steps and uses  registers. We also present three implementations (namely, T-Opt, RT and RT-Opt) that beat the  lower bound by using more registers. Specifically, T-Opt has step complexity O(1) for UPDATE and O(m) for SCAN. This step complexity is optimal, but the number of registers that T-Opt uses is unbounded. We then present interesting recycling techniques to bound the number and the size of registers used, resulting in RT and RT-Opt. Specifically, RT-Opt, which has optimal step \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:r0BpntZqJG4C",
            "Publisher": "Springer Berlin Heidelberg"
        },
        {
            "Title": "Welcome to the Europe region special section",
            "Publication year": 2019,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3309913",
            "Abstract": "The computing community throughout the European Region is championing many enterprising industry, academic, and government initiatives to further develop the field and ensure a workforce prepared to take it on.The articles in this special section, written by some of the leading voices in the region, tell stories of informatics and ICT innovations, Web science in Europe, the EuroHPC, future research directions planned for this vibrant part of the world, and much more.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:35N4QoGY0k4C",
            "Publisher": "ACM"
        },
        {
            "Title": "The PCL theorem: transactions cannot be parallel, consistent, and live",
            "Publication year": 2018,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3266141",
            "Abstract": "We establish a theorem called the PCL theorem, which states that it is impossible to design a transactional memory algorithm that ensures (1) parallelism, i.e., transactions do not need to synchronize unless they access the same application objects, (2) very little consistency, i.e., a consistency condition, called weak adaptive consistency, introduced here and that is weaker than snapshot isolation, processor consistency, and any other consistency condition stronger than them (such as opacity, serializability, causal serializability, etc.), and (3) very little liveness, i.e., which transactions eventually commit if they run solo.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:4JMBOYKVnBMC",
            "Publisher": "ACM"
        },
        {
            "Title": "The RedBlue Adaptive Universal Constructions",
            "Publication year": 2009,
            "Publication url": "https://link.springer.com/chapter/10.1007/978-3-642-04355-0_15",
            "Abstract": "We present the family of RedBlue algorithms, a collection of universal wait-free constructions for linearizable shared objects in an asynchronous shared-memory distributed system with n processes. The algorithms are adaptive and improve upon previous algorithms in terms of their time and/or space complexity.The first of the algorithms achieves better time complexity than all previously presented algorithms but it is impractical since it uses large LL/SC registers. This algorithm comprises the keystone for the design of the other RedBlue algorithms which are of practical interest. The second algorithm significantly reduces the size of the required registers and it is therefore practical in many cases. The last two algorithms work efficiently for large objects improving previous universal constructions for large objects presented by Anderson and Moir (PODC 1995).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:Y0pCki6q_DkC",
            "Publisher": "Springer, Berlin, Heidelberg"
        },
        {
            "Title": "Announcing the 2012 Edsger W. Dijkstra Prize in Distributed Computing",
            "Publication year": 2012,
            "Publication url": "http://150.140.5.98/index.php/beatcs/article/viewFile/51/47",
            "Abstract": "The ACM-EATCS Edsger W. Dijkstra Prize in Distributed Computing is awarded to outstanding papers on the principles of distributed computing, whose significance and impact on the theory or practice of distributed computing have been evident for at least ten years. The prize is sponsored jointly by the ACM",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:aqlVkmm33-oC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Front Matter, Table of Contents, Preface, Committees, List of Authors",
            "Publication year": 2017,
            "Publication url": "https://drops.dagstuhl.de/opus/volltexte/2017/7069/pdf/LIPIcs-OPODIS-2016-0.pdf",
            "Abstract": "OPODIS is an open forum for the exchange of state-of-the-art knowledge on distributed computing. With strong roots in the theory of distributed systems, OPODIS has expanded its scope to cover the whole range between the theoretical aspects and practical implementations of distributed systems, as well as experimentation and quantitative assessments. All aspects of distributed systems are within the scope of OPODIS: theory, specification, design, performance, and system building. Specifically, this year the topics of interest of OPODIS included:Design and analysis of distributed algorithms Synchronization, concurrent algorithms, shared and transactional memory Design and analysis of concurrent and distributed data structures Communication networks (protocols, architectures, services, applications) High-performance, cluster, cloud and grid computing Mesh and ad-hoc networks (wireless, mobile, sensor), location and context-aware systems Mobile agents, robots, and rendezvous",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:mB3voiENLucC",
            "Publisher": "Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik"
        },
        {
            "Title": "Time lower bounds for implementations of multi-writer snapshots",
            "Publication year": 2007,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/1314690.1314694",
            "Abstract": "A snapshot object is an abstraction of the problem of obtaining a consistent view of the contents of shared memory in a distributed system, despite concurrent changes to the memory. There are implementations of m-component snapshot objects shared by n \u2265 m processes using m registers. This is the minimum number of registers possible. We prove a time lower bound for implementations that use this minimum number of registers. It matches the time taken by the fastest such implementation. Our proof yields insight into the structure of any such implementation, showing that processes must access the registers in a very constrained way. We also prove a time lower bound for snapshot implementations using single-writer registers in addition to m historyless objects (such as registers and swap objects).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:eQOLeE2rZwMC",
            "Publisher": "ACM"
        },
        {
            "Title": "Hybrid Data Driven and Rule Based Sentiment Analysis on Greek Text",
            "Publication year": 2020,
            "Publication url": "https://www.sciencedirect.com/science/article/pii/S1877050920323991",
            "Abstract": "Sentiment analysis is a developing field dealing with the detection of sentiments or opinions expressed in a written text. In an age where online services are subject to immediate feedback by users and clients, sentiment analysis on bodies of online reviews is of particular interest to service-oriented businesses such as hospitality establishments. Methods based on Machine Learning are very widely used for this purpose. While some standardized methodologies exist, the sheer volume of data on which the analysis is to be performed in order to train a Deep Learning network, makes it important to come up with designs that are sufficiently complex so as to accurately detect sentiment but also simple enough so as to be scalable and efficient in terms of performance.In this paper, we examine trade-offs of accuracy versus efficiency by performing sentiment analysis on an annotated body of review texts collected from \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:cFHS6HbyZ2cC",
            "Publisher": "Elsevier"
        },
        {
            "Title": "Space and Time Bounded Multiversion Garbage Collection",
            "Publication year": 2021,
            "Publication url": "https://arxiv.org/abs/2108.02775",
            "Abstract": "We present a general technique for garbage collecting old versions for multiversion concurrency control that simultaneously achieves good time and space complexity. Our technique takes only  time on average to reclaim each version and maintains only a constant factor more versions than needed (plus an additive term). It is designed for multiversion schemes using version lists, which are the most common. Our approach uses two components that are of independent interest. First, we define a novel range-tracking data structure which stores a set of old versions and efficiently finds those that are no longer needed. We provide a wait-free implementation in which all operations take amortized constant time. Second, we represent version lists using a new lock-free doubly-linked list algorithm that supports efficient (amortized constant time) removals given a pointer to any node in the list. These two components naturally fit together to solve the multiversion garbage collection problem--the range-tracker identifies which versions to remove and our list algorithm can then be used to remove them from their version lists. We apply our garbage collection technique to generate end-to-end time and space bounds for the multiversioning system of Wei et al. (PPoPP 2021).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:b0M2c_1WBrUC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Time-space tradeoffs for implementations of snapshots",
            "Publication year": 2006,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/1132516.1132542",
            "Abstract": "A snapshot object is an abstraction of the fundamental problem of obtaining a consistent view of the contents of the shared memory in a distributed system while other processes may concurrently update those contents. A snapshot object stores an array of m components and can be accessed by two operations: an UPDATE that changes the value of an individual component and a powerful SCAN that returns the contents of the entire array. This paper proves time-space tradeoffs for fault-tolerant implementations of a snapshot object from registers that support only Read and Write operations. For anonymous implementations (where all processes are programmed identically), we prove that a SCAN requires \u03a9 (n/r) time, where n is the number of processes in the system and r is the number of registers used by the implementation. For the general non-anonymous case, we prove that, for any fixed r, the time required to \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:UeHWp8X0CEIC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Persistent non-blocking binary search trees supporting wait-free range queries",
            "Publication year": 2019,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3323165.3323197",
            "Abstract": "This paper presents the first implementation of a search tree data structure in an asynchronous shared-memory system that provides a wait-free algorithm for executing range queries on the tree, in addition to non-blocking algorithms for Insert, Delete and Find, using single-word Compare-and-Swap (CAS). The implementation is linearizable and tolerates any number of crash failures. Insert and Delete operations that operate on different parts of the tree run fully in parallel (without any interference with one another). We employ a lightweight helping mechanism, where each Insert, Delete and Find operation helps only update operations that affect the local neighbourhood of the leaf that the Find arrives at. Similarly, a range query helps only those updates taking place on nodes in the part of the tree it traverses. Our implementation works in a dynamic system where the number of processes may change over time. The \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:lSLTfruPkqcC",
            "Publisher": "Unknown"
        },
        {
            "Title": "A tight time lower bound for space-optimal implementations of multi-writer snapshots",
            "Publication year": 2003,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/780542.780582",
            "Abstract": "A snapshot object consists of a collection of m> 1 components, each capable of storing a value, shared by n processes in an asynchronous shared-memory distributed system. It supports two operations: a process can UPDATE any individual component or atomically SCAN the entire collection to obtain the values of all the components. It is possible to implement a snapshot object using m registers so that each operation takes O (mn) time. In a previous paper, we proved that m registers are necessary to implement a snapshot object with m< n-1 components. Here we prove that, for any such space-optimal implementation, \u03a9 (mn) steps are required to perform a SCAN operation in the worst case, matching the upper bound. We also extend our space and time lower bounds to implementations that use single-writer registers in addition to the multi-writer registers. Specifically, we prove that at least m multi-writer registers are \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:d1gkVwhDpl0C",
            "Publisher": "Unknown"
        },
        {
            "Title": "Efficient scheduling of strict multithreaded computations",
            "Publication year": 2000,
            "Publication url": "https://link.springer.com/article/10.1007/s002240010002",
            "Abstract": " In this paper we study the problem of efficiently scheduling a wide class of multithreaded computations, called strict; that is, computations in which all dependencies from a thread go to the thread's ancestors in the computation tree. Strict multithreaded computations allow the limited use of synchronization primitives. We present the first  fully distributed scheduling algorithm which applies to any  strict multithreaded computation. The algorithm is asynchronous, on-line, and follows the work-stealing  paradigm. We prove that our algorithm is efficient not only in terms of its memory requirements and its execution time, but also in terms of its communication complexity. Our analysis applies to both shared and distributed memory machines. More specifically, the expected execution time of our algorithm is O(T  1  /P + hT  \u2208fty \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:Tyk-4Ss8FVUC",
            "Publisher": "Springer-Verlag"
        },
        {
            "Title": "A Tight Time Lower Bound for Space-Optimal",
            "Publication year": 2002,
            "Publication url": "https://scholar.google.com/scholar?cluster=5355998157020408843&hl=en&oi=scholarr",
            "Abstract": "A snapshot object consists of a collection of m> 1 components, each capable of storing a value, shared by n processes in an asynchronous shared-memory distributed system. It supports two operations: a process can UPDATE any individual component or atomically SCAN the entire collection to obtain the values of all the components. It is possible to implement a snapshot object using m registers so that each operation takes (mn) time.In a previous paper, we proved that m registers are necessary to implement a snapshot object with m< n-1 components. Here we prove that, for any such space-optimal implementation, N (mn) steps are required to perform a SCAN operation in the worst case, matching the upper bound. We also extend our space and time lower bounds to implementations that use single-writer registers in addition to the multi-writer registers. Specifically, we prove that at least m multi-writer registers are still needed, provided the SCANS do not read a large fraction of the single-writer registers. We also prove that any implementation that uses singlewriter registers in addition to m multi-writer registers uses 2 (mn) steps in the worst case. Our proof yields insight into the structure of any implementation that uses only m multi-writer registers, showing that processes must access the multi-writer registers in a very constrained way.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:bFI3QPDXJZMC",
            "Publisher": "Association for Computing Machinery"
        },
        {
            "Title": "Constant-time snapshots with applications to concurrent data structures",
            "Publication year": 2021,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3437801.3441602",
            "Abstract": "Given a concurrent data structure, we present an approach for efficiently taking snapshots of its constituent CAS objects. More specifically, we support a constant-time operation that returns a snapshot handle. This snapshot handle can later be used to read the value of any base object at the time the snapshot was taken. Reading an earlier version of a base object is wait-free and takes time proportional to the number of successful writes to the object since the snapshot was taken. Importantly, our approach preserves all the time bounds and parallelism of the original data structure.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:4OULZ7Gr8RgC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Distributed Computing",
            "Publication year": 2015,
            "Publication url": "http://eatcs.org/beatcs/index.php/beatcs/article/download/326/308",
            "Abstract": "In this survey article, I will present three ideas, regarding the construction of concurrent data structures and algorithms, recently published in [27, 28, 29]. The first idea is that of contention-sensitivity. A contention-sensitive data structure is a concurrent data structure in which the overhead introduced by locking is eliminated in common cases, when there is no contention, or when processes with non-interfering operations access it concurrently. This notion is formally defined, several contention-sensitive data structures are presented, and transformations that facilitate devising such data structures are discussed.The second idea is the introduction of a new synchronization problem, called fair synchronization. Solving the new problem enables to automatically add strong fairness guarantees to existing implementations of concurrent data structures, without using locks, and to transform any solution to the mutual exclusion problem into a fair solution. The third idea is a generalization of the traditional notion of fault tolerance. Important classical problems have no asynchronous solutions which can tolerate even a single fault. It is shown that while some of these problems have solutions which guarantee that in the presence of any number of faults most of the correct processes will terminate, other problems do not even have solutions which guarantee that in the presence of just one fault at least one correct process terminates.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:TFP_iSt0sucC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Abort free semantictm by dependency aware scheduling of transactional instructions",
            "Publication year": 2014,
            "Publication url": "https://link.springer.com/chapter/10.1007/978-3-319-09581-3_3",
            "Abstract": "We present a TM system that executes transactions without ever causing any aborts. The system uses a set of t-var lists, one for each transactional variable. The instructions of each transaction are placed in the appropriate t-var lists based on which t-variable each of them accesses. A set of worker threads are responsible to execute these instructions. Because of the way instructions are inserted in and removed from the lists, by the way the worker threads work, and by the fact that all the instructions of a transaction are placed in the appropriate t-var lists before doing so for the instructions of any subsequent transaction, it follows that no conflict will ever occur. Parallelism is fine-grained since it is achieved at the level of transactional instructions instead of transactions themselves (i.e., the instructions of a transaction may be executed concurrently).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:iH-uZ7U-co4C",
            "Publisher": "Springer, Cham"
        },
        {
            "Title": "Tracking in Order to Recover-Detectable Recovery of Lock-Free Data Structures",
            "Publication year": 2020,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3350755.3400257",
            "Abstract": "We present the tracking approach for deriving detectable implementations of many widely-used concurrent data structures for systems with non-volatile main memory (NVRAM). Detectable recovery ensures that in the crash-recovery model, every operation executed during a crash, resumes its execution and returns a correct response, and that the state of the data structure is not corrupted.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:dfsIfKJdRG4C",
            "Publisher": "Unknown"
        },
        {
            "Title": "Fast implementations of shared objects using fetch&add",
            "Publication year": 2010,
            "Publication url": "https://www.researchgate.net/profile/Nikolaos-Kallimanis/publication/228550877_Fast_Implementations_of_Shared_Objects_using_FetchAdd/links/5469f82e0cf2f5eb18076fca/Fast-Implementations-of-Shared-Objects-using-Fetch-Add.pdf",
            "Abstract": "In this paper we present efficient implementations of shared objects from Fetch&Add registers. We present the first snapshot implementation which has time complexity O (1) for both scan and update. Using this implementation we can directly obtain an active set with constant time complexity for all three operations, join, leave and getSet. We also present the first universal construction which has time complexity O (1). This construction proves that a lower bound of \u2126 (log n) on the number of LL/SC registers required for implementing a universal object can be beaten if we employ a constant number of Fetch&Add registers (in addition to one LL/SC register). Our algorithms improve upon existing implementations of these objects and they have several interesting implications on the complexity of many known implementations of other shared objects that use any of the implemented objects as one of their components (ie, existing partial snapshot algorithms and others). Despite these implications, they are themselves very simple and some of them are of practical interest in several cases.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:3fE2CSJIrl8C",
            "Publisher": "Technical Report TR 02-2010, Department of Computer Science, University of Ioannina"
        },
        {
            "Title": "Concurrency for the Masses: The Paradigm of Software Transactional Memory",
            "Publication year": 2017,
            "Publication url": "https://ieeexplore.ieee.org/abstract/document/8531258/",
            "Abstract": "This paper reviews the basics of Software Transactional Memory (STM) algorithms, examines some of their properties, and briefly discusses a collection of impossibility and possibility results in STM computing. The material presented in this paper summarizes the main points of the talk that the author delivered in the 19th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC 2017) as an invited speaker through the ACM Distinguished Speakers Programme.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:2P1L_qKh6hAC",
            "Publisher": "IEEE"
        },
        {
            "Title": "Universal constructions that ensure disjoint-access parallelism and wait-freedom",
            "Publication year": 2012,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/2332432.2332457",
            "Abstract": "Disjoint-access parallelism and wait-freedom are two desirable properties for implementations of concurrent objects. Disjoint-access parallelism guarantees that processes operating on different parts of an implemented object do not interfere with each other by accessing common base objects. Thus, disjoint-access parallel algorithms allow for increased parallelism. Wait-freedom guarantees progress for each non-faulty process, even when other processes run at arbitrary speeds or crash.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:roLk4NBRz8UC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Consistency for transactional memory computing",
            "Publication year": 2015,
            "Publication url": "https://link.springer.com/chapter/10.1007/978-3-319-14720-8_1",
            "Abstract": "This chapter provides formal definitions for a comprehensive collection of consistency conditions for transactional memory (TM) computing. We express all conditions in a uniform way using a formal framework that we present. For each of the conditions, we provide two versions: one that allows a transaction T to read the value of a data item written by another transaction T\u2032 that can be live and not yet commit-pending provided that T\u2032 will eventually commit, and a version which allows transactions to read values written only by transactions that have either committed before T starts or are commit-pending. Deriving the first version for a consistency condition was not an easy task but it has the benefit that this version is weaker than the second one and so it results in a wider universe of algorithms which there is no reason to exclude from being considered correct. The formalism for the presented consistency \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:e5wmG9Sq2KIC",
            "Publisher": "Springer, Cham"
        },
        {
            "Title": "Distributed data structures for future many-core architectures",
            "Publication year": 2015,
            "Publication url": "https://www.ics.forth.gr/tech-reports/2015/2015.TR447.Apr2015.pdf",
            "Abstract": "We present general techniques for implementing distributed data structures, such as stacks, queues, dequeues, lists, and sets, on top of future many-core architectures with non cache-coherent or partially cache-coherent memory. With the goal of contributing towards what might become, in the future, the concurrency utilities package in Java collections for such architectures, we implemented a comprehensive collection of data structures, richer than that provided in java. util. concurrent, by considering different variants of these techniques. To achieve scalability, we present a generic scheme which can be used to make all our implementations hierarchical. We also describe a large collection of techniques for further improving scalability in most implementations. We have compiled a library of the proposed data structures and performed experiments on top of a non cache-coherent 512-core architecture which is built using 64 hardware prototyping boards. The experiments illustrate nice scalability characteristics for the proposed techniques and reveal the performance and scalability power of the hierarchical approach.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:O3NaXMp0MMsC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Lock Oscillation: Boosting the Performance of Concurrent Data Structures",
            "Publication year": 2018,
            "Publication url": "https://drops.dagstuhl.de/opus/volltexte/2018/8628/",
            "Abstract": "In combining-based synchronization, two main parameters that affect performance are the com-bining degree of the synchronization algorithm, ie the average number of requests that each com-biner serves, and the number of expensive synchronization primitives (like CAS, Swap, etc.) that it performs. The value of the first parameter must be high, whereas the second must be kept low. In this paper, we present Osci, a new combining technique that shows remarkable perform-ance when paired with cheap context switching. We experimentally show that Osci significantly outperforms all previous combining algorithms. Specifically, the throughput of Osci is higher than that of previously presented combining techniques by more than an order of magnitude. Notably, Osci\u2019s throughput is much closer to the ideal than all previous algorithms, while keep-ing the average latency in serving each request low. We evaluated the performance of Osci in two different multiprocessor architectures, namely AMD and Intel. Based on Osci, we implement and experimentally evaluate implementations of concurrent queues and stacks. These implementations outperform by far all current state-of-the-art concur-rent queue and stack implementations. Although the current version of Osci has been evaluated in an environment supporting user-level threads, it would run correctly on any threading library, preemptive or not (including kernel threads).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:j3f4tGmQtD8C",
            "Publisher": "Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik"
        },
        {
            "Title": "Special issue on OPODIS 2016 Preface",
            "Publication year": 2020,
            "Publication url": "https://scholar.google.com/scholar?cluster=2485627465141269750&hl=en&oi=scholarr",
            "Abstract": "Unknown",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:u_35RYKgDlwC",
            "Publisher": "ELSEVIER"
        },
        {
            "Title": "Max-Min Fair Flow Control Sensitive to Priorities",
            "Publication year": 2005,
            "Publication url": "https://www.worldscientific.com/doi/abs/10.1142/S0219265905001332",
            "Abstract": "Flow control is the dominant technique currently used in  communication networks for preventing excess traffic from flooding the  network, and for handling congestion. In rate-based flow  control, transmission rates of sessions are adjusted in an end-to-end  manner through a sequence of operations. In this work, we  present a theory of max-min fair, rate-based flow control  sensitive to priorities of different sessions, as a significant  extension of the classical theory of max-min fair, rate-based flow  control to networks supporting applications with diverse requirements  on network resources.Each individual session bears a priority function, which  maps the session's priority to a transmission rate; the priority is a  working abstraction of the session's priority to bandwidth access.  Priority functions enable the specification of requirements on bandwidth access by distributed applications, and the formal handling of such \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:qxL8FJ1GzNcC",
            "Publisher": "World Scientific Publishing Company"
        },
        {
            "Title": "Efficient Distributed Data Structures for Future Many-Core Architectures",
            "Publication year": 2016,
            "Publication url": "https://ieeexplore.ieee.org/abstract/document/7823828/",
            "Abstract": "We study general techniques for implementing distributed data structures on top of future many-core architectures with non cache-coherent or partially cache-coherent memory. With the goal of contributing towards what might become, in the future, the concurrency utilities package in Java collections for such architectures, we end up with a comprehensive collection of data structures by considering different variants of these techniques. To achieve scalability, we study a generic scheme which makes all our implementations hierarchical. We also describe a collection of techniques for further improving scalability in most implementations. We have performed experiments which illustrate nice scalability characteristics for some of the proposed techniques and reveal the performance and scalability power of the hierarchical approach. We distill the experimental observations into a metric that expresses the scalability \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:HDshCWvjkbEC",
            "Publisher": "IEEE"
        },
        {
            "Title": "Paris+: Data series indexing on multi-core architectures",
            "Publication year": 2020,
            "Publication url": "https://ieeexplore.ieee.org/abstract/document/9003246/",
            "Abstract": "Data series similarity search is a core operation for several data series analysis applications across many different domains. Nevertheless, even state-of-the-art techniques cannot provide the time performance required for large data series collections. We propose ParIS and ParIS+, the  first  disk-based data series indices carefully designed to inherently take advantage of multi-core architectures, in order to accelerate similarity search processing times. Our experiments demonstrate that ParIS+ completely removes the CPU latency during index construction for disk-resident data, and for exact query answering is up to 1 order of magnitude faster than the current state of the art index scan method, and up to 3 orders of magnitude faster than the optimized serial scan method. ParIS+ (which is an evolution of the ADS+ index) owes its efficiency to the effective use of multi-core and multi-socket architectures, in order to \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:3s1wT3WcHBgC",
            "Publisher": "IEEE"
        },
        {
            "Title": "Abort free semantictm by dependency aware scheduling of transactional instructions",
            "Publication year": 2013,
            "Publication url": "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.357.2600&rep=rep1&type=pdf",
            "Abstract": "We present a TM system that executes transactions without ever causing any aborts. The system uses a set of t-var lists, one for each transactional variable. A scheduler undertakes the task of placing the instructions of each transaction in the appropriate t-var lists based on which t-variable each of them accesses. A set of worker threads are responsible to execute these instructions. Because of the way instructions are inserted in and removed from the lists, by the way the worker threads work, and by the fact that the scheduler places all the instructions of a transaction in the appropriate tvar lists before doing so for the instructions of any subsequent transaction, it follows that no conflict will ever occur. Parallelism is fine-grained since it is achieved at the level of transactional instructions instead of transactions themselves (ie, the instructions of a transaction may be executed concurrently).",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:Wp0gIr-vW9MC",
            "Publisher": "Unknown"
        },
        {
            "Title": "A highly-efficient wait-free universal construction",
            "Publication year": 2011,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/1989493.1989549",
            "Abstract": "We present a new simple wait-free universal construction, called Sim, that uses just a Fetch&Add and an LL/SC object and performs a constant number of shared memory accesses. We have implemented SIM in a real shared-memory machine. In theory terms, our practical version of SIM, called P-SIM, has worse complexity than its theoretical analog; in practice though, we experimentally show that P-SIM outperforms several state-of-the-art lock-based and lock-free techniques, and this given that it is wait-free, ie, that it satisfies a stronger progress condition than all the algorithms it outperforms.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:u-x6o8ySG0sC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Paris: The next destination for fast data series indexing and query answering",
            "Publication year": 2018,
            "Publication url": "https://ieeexplore.ieee.org/abstract/document/8622293/",
            "Abstract": "We propose ParIS, the first disk-based data series index that inherently takes advantage of modern hardware parallelization, in order to accelerate processing times. Our experimental results demonstrate that ParIS completely removes the CPU latency during index construction for disk-resident data. In terms of exact query answering, ParIS is more than 2 orders of magnitude faster than the current state of the art index scan method, and more than 3 orders of magnitude faster than the optimized serial scan method. ParIS owes its efficiency not only to the effective use of multi-core and multi-socket architectures, in order to distribute and execute in parallel both index construction and query answering, but also to the exploitation of the Single Instruction Multiple Data (SIMD) capabilities of modern CPUs, in order to further parallelize the execution of individual instructions inside each core.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:YFjsv_pBGBYC",
            "Publisher": "IEEE"
        },
        {
            "Title": "Transactional Memory: A Primer for Theorists",
            "Publication year": 2009,
            "Publication url": "https://scholar.google.com/scholar?cluster=1527697569850745748&hl=en&oi=scholarr",
            "Abstract": "This article gives a brief overview of Transactional Memory, and speculates about some open research questions.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:RHpTSmoSYBkC",
            "Publisher": "EUROPEAN ASSOC THEORETICAL COMPUTER SCIENCE"
        },
        {
            "Title": "Persistent Software Combining",
            "Publication year": 2021,
            "Publication url": "https://arxiv.org/abs/2107.03492",
            "Abstract": "We study the performance power of software combining in designing persistent algorithms and data structures. We present Bcomb, a new blocking highly-efficient combining protocol, and built upon it to get PBcomb, a persistent version of it that performs a small number of persistence instructions and exhibits low synchronization cost. We built fundamental recoverable data structures, such as stacks and queues based on PBcomb, as well as on PWFcomb, a wait-free universal construction we present. Our experiments show that PBcomb and PWFcomb outperform by far state-of-the-art recoverable universal constructions and transactional memory systems, many of which ensure weaker consistency properties than our algorithms. We built recoverable queues and stacks, based on PBcomb and PWFcomb, and present experiments to show that they have much better performance than previous recoverable implementations of stacks and queues. We build the first recoverable implementation of a concurrent heap and present experiments to show that it has good performance when the size of the heap is not very large.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:EUQCXRtRnyEC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Low-contention depth-first scheduling of parallel computations with synchronization variables",
            "Publication year": 2000,
            "Publication url": "https://pure.mpg.de/pubman/faces/ViewItemOverviewPage.jsp?itemId=item_1819326",
            "Abstract": "In this paper, we present a randomized, online, space-efficient algorithm for the general class of programs with synchronization variables (such programs are produced by parallel programming languages, like, eg, Cool, ID, Sisal, Mul-T, OLDEN and Jade). The algorithm achieves good locality and low scheduling overheads for this general class of computations, by combining work-stealing and depth-first scheduling. More specifically, given a computation with work , depth  and  synchronizations that its execution requires space  on a single-processor computer, our algorithm achieves expected space complexity at most  and runs in an expected number of  timesteps on a shared-memory, parallel machine with  processors. Moreover, for any , the space complexity of our algorithm is at most $ S_1+ O (P (T_\\infty+\\ln (1/\\varepsilon))\\log (P (T_\\infty+\\ln (P (T_\\infty+\\ln (1/\\varepsilon))/\\varepsilon)))) $ with probability at least . Thus, even for values of  as small as , the space complexity of our algorithm is at most , with probability at least . The algorithm achieves good locality and low scheduling overheads by automatically increasing the granularity of the work scheduled on each processor. Our results combine and extend previous algorithms and analysis techniques (published by Blelloch et. al [6] and by Narlikar [26]). Our algorithm not only exhibits the same good space complexity for the general class of programs with synchronization variables as its deterministic analog presented in [6], but it also achieves good locality and low scheduling \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:M3ejUd6NZC8C",
            "Publisher": "Max-Planck-Institut f\u00fcr Informatik"
        },
        {
            "Title": "Eight Open Problems in Distributed Computing.",
            "Publication year": 2006,
            "Publication url": "http://www.cs.yale.edu/homes/aspnes/papers/beatcs-column-2006.pdf",
            "Abstract": "Distributed Computing Theory continues to be one of the most active research fields in Theoretical Computer Science today. Besides its foundational topics (such as consensus and synchronization), it is currently being enriched with many new topics inspired from modern technological advances (eg, the Internet). In this note, we present eight open problems in Distributed Computing Theory that span a wide range of topics\u2013both classical and modern.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:zYLM7Y9cAGgC",
            "Publisher": "Unknown"
        },
        {
            "Title": "20th International Conference on Principles of Distributed Systems",
            "Publication year": 2017,
            "Publication url": "http://toc.proceedings.com/34113webtoc.pdf",
            "Abstract": "LIPIcs, Vol. 70, OPODIS 2016 - Complete Volume Page 1 20th International Conference on \nPrinciples of Distributed Systems OPODIS 2016, December 13\u201316, 2016, Madrid, Spain Edited \nby Panagiota Fatourou Ernesto Jim\u00e9nez Fernando Pedone LIPIcs \u2013 Vol. 70 \u2013 OPODIS 2016 \nwww.dagstuhl.de/lipics Page 2 Editors Panagiota Fatourou Ernesto Jim\u00e9nez Fernando Pedone \nFORTH ICS & Depart. of Technical University of University of Lugano (USI) Comp. Sci., Univ. \nof Crete Madrid (UPM) Crete Madrid Lugano Greece Spain Switzerland faturu@ics.forth.gr \nernes@etsisi.upm.es fernando.pedone@usi.ch ACM Classification 1998 C.2.4 Distributed \nSystems, C.4 Performance of Systems, D.1.3 Concurrent Programming, E.1 Data Structures, \nF.1.2 Modes of Computation ISBN 978-3-95977-031-6 Published online and open access \nby Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik GmbH, Dagstuhl Publishing, /Wadern, :\u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:ldfaerwXgEUC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Distributed transactional systems cannot be fast",
            "Publication year": 2019,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/3323165.3323189",
            "Abstract": "We prove that no fully transactional system can provide fast read transactions (including read-only ones that are considered the most frequent in practice). Specifically, to achieve fast read transactions, the system has to give up support of transactions that write more than one object. We prove this impossibility result for distributed storage systems that are causally consistent, ie, they do not require to ensure any strong form of consistency. Therefore, our result holds also for any system that ensures a consistency level stronger than causal consistency, eg, strict serializability. The impossibility result holds even for systems that store only two objects (and support at least two servers and at least four clients). It also holds for systems that are partially replicated. Our result justifies the design choices of state-of-the-art distributed transactional systems and insists that system designers should not put more effort to design fully \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:J_g5lzvAfSwC",
            "Publisher": "Unknown"
        },
        {
            "Title": "The amortized complexity of non-blocking binary search trees",
            "Publication year": 2014,
            "Publication url": "https://dl.acm.org/doi/abs/10.1145/2611462.2611486",
            "Abstract": "We improve upon an existing non-blocking implementation of a binary search tree from single-word compare-and-swap instructions. We show that the worst-case amortized step complexity of performing a Find, Insert or Delete operation op on the tree is O (h (op)+ c (op)) where h (op) is the height of the tree at the beginning of op and c (op) is the maximum number of operations accessing the tree at any one time during op. This is the first bound on the complexity of a non-blocking implementation of a search tree.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:ns9cj8rnVeAC",
            "Publisher": "Unknown"
        },
        {
            "Title": "Adding networks",
            "Publication year": 2001,
            "Publication url": "https://link.springer.com/chapter/10.1007/3-540-45414-4_23",
            "Abstract": "An adding network is a distributed data structure that supports a concurrent, lock-free, low-contention implementation of a fetch\u2130add counter; a counting network is an instance of an adding network that supports only fetch\u2130increment. We present a lower bound showing that adding networks have inherently high latency. Any adding network powerful enough to support addition by at least two values a and b, where |a| > |b| > 0, has sequential executions in which each token traverses \u03a9(n/c) switching elements, where n is the number of concurrent processes, and c is a quantity we call one-shot contention; for a large class of switching networks and for conventional counting networks the one-shot contention is constant. On the contrary, counting networks have O(log n) latency [4,7.This bound is tight. We present the first concurrent, lock-free, lowcontention networked data structure that supports arbitrary \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:YsMSGLbcyi4C",
            "Publisher": "Springer, Berlin, Heidelberg"
        },
        {
            "Title": "Staleness and Local Progress in Transactional Memory",
            "Publication year": 2020,
            "Publication url": "https://link.springer.com/chapter/10.1007/978-3-030-67087-0_15",
            "Abstract": "A key goal in the design of Transactional Memory (TM) systems is ensuring liveness. Local progress is a liveness condition which ensures that a process successfully completes every transaction it initiates, if it continually re-invokes it each time it aborts. In order to facilitate this, several state-of-the-art TM systems keep multiple versions of data items. However, this method can lead to high space-related overheads in the TM implementation. Therefore, it is desirable to strike a balance between the progress that a TM can provide and its practicality, while ensuring correctness. A consistency property that limits the number of previous versions a TM may rely on, is k-staleness. It is a condition derivative of snapshot isolation, in which a transaction is not allowed to access more than k previous versions of a data item. This facilitates implementations that can take advantage of multi-versioning, while at the same \u2026",
            "Abstract entirety": 0,
            "Author pub id": "ZgHRkcUAAAAJ:D03iK_w7-QYC",
            "Publisher": "Springer, Cham"
        },
        {
            "Title": "The complexity of updating snapshot objects",
            "Publication year": 2011,
            "Publication url": "https://www.sciencedirect.com/science/article/pii/S0743731511001596",
            "Abstract": "This paper proves \u03a9 (m) lower bounds on the step complexity of UPDATE operations for space-optimal wait-free implementations of an m-component snapshot object from historyless objects. These lower bounds follow from lower bounds for a new, more general class of implementations from base objects of any type. This work extends a similar lower bound by Israeli and Shirazi for implementations of m-component single-writer snapshot objects from single-writer registers.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:YOwf2qJgpHMC",
            "Publisher": "Academic Press"
        },
        {
            "Title": "The complexity of updating multi-writer snapshot objects",
            "Publication year": 2006,
            "Publication url": "https://link.springer.com/chapter/10.1007/11947950_35",
            "Abstract": "This paper proves \u03a9(m) lower bounds on the step complexity of UPDATE operations for partitioned implementations of m-component multi-writer snapshot objects from base objects of any type. These are implementations in which each base object is only modifed by processes performing UPDATE operations to one specific component. In particular, we show that any space-optimal implementation of a multi-writer snapshot object from historyless objects is partitioned. This work extends a similar lower bound by Israeli and Shirazi for implementations of m-component single-writer snapshot objects from single-writer registers.",
            "Abstract entirety": 1,
            "Author pub id": "ZgHRkcUAAAAJ:Se3iqnhoufwC",
            "Publisher": "Springer, Berlin, Heidelberg"
        }
    ]
}]